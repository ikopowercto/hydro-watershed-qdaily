<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Hydro Débits - Bassin Versant</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/georaster"></script>
  <script src="https://unpkg.com/georaster-layer-for-leaflet"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
    #map { height: 500px; }
    #controls { padding: 1em; }
  </style>
</head>
<body>
  <h1 style="text-align:center">Hydro Débits - Délimitation de Bassin Versant</h1>
  <div id="map"></div>
  <div id="controls">
    <label>Coefficient de ruissellement (C): <input type="number" id="coef" value="0.5" step="0.05" min="0" max="1"></label><br>
    <label>Fraction souterraine (k): <input type="number" id="kfrac" value="0.2" step="0.05" min="0" max="1"></label><br>
    <button onclick="calculerDebits()">Calculer Débits Journaliers</button>
    <pre id="output"></pre>
  </div>

  <script>
    let map = L.map('map').setView([46.5, 2.5], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 18,
    }).addTo(map);

    let outletMarker;
    let outletCoords;
    let basinGeoJSON;

    map.on('click', async function(e) {
      if (outletMarker) map.removeLayer(outletMarker);
      if (basinGeoJSON) map.removeLayer(basinGeoJSON);

      outletCoords = e.latlng;
      outletMarker = L.marker(outletCoords).addTo(map).bindPopup("Exutoire").openPopup();

      // Récupération du bassin via Delineator
      const url = `https://delineator.appspot.com/delineate?lat=${outletCoords.lat}&lon=${outletCoords.lng}&format=geojson`;
      try {
        const basin = await fetch(url).then(r => r.json());
        basinGeoJSON = L.geoJSON(basin, {color: 'blue'}).addTo(map);
        const area_m2 = turf.area(basin);
        const A_km2 = (area_m2 / 1e6).toFixed(2);
        alert(`Surface du bassin : ${A_km2} km²`);
        map.fitBounds(basinGeoJSON.getBounds());
        map.basinPolygon = basin; // stocker pour les calculs
      } catch (err) {
        alert("Erreur lors de la récupération du bassin");
      }
    });

    async function fetchWorldClim(month, lat, lng, res='10m') {
      const url = `https://biogeo.ucdavis.edu/data/worldclim/v2.1/base/wc2.1_${res}_prec_${month}.tif`;
      const response = await fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      const georaster = await parseGeoraster(arrayBuffer);
      let pixelValue = georaster.values[0][Math.floor(georaster.height/2)][Math.floor(georaster.width/2)];
      return pixelValue;
    }

    async function calculerDebits() {
      if (!outletCoords || !map.basinPolygon) {
        alert("Cliquez sur la carte pour définir l’exutoire et récupérer le bassin.");
        return;
      }
      const C = parseFloat(document.getElementById('coef').value);
      const k = parseFloat(document.getElementById('kfrac').value);

      const area_m2 = turf.area(map.basinPolygon);
      const A_m2 = area_m2;

      let dailyQ = [];
      let totalP = 0;

      for (let m = 1; m <= 12; m++) {
        const P_month = await fetchWorldClim(m, outletCoords.lat, outletCoords.lng);
        totalP += P_month;
        const daysInMonth = new Date(2000, m, 0).getDate();
        const P_day = P_month / daysInMonth;
        for (let d = 0; d < daysInMonth; d++) {
          dailyQ.push(P_day);
        }
      }

      // Débit annuel moyen
      let Vann = (totalP / 1000) * A_m2; // m3/an
      let Qann = Vann / (365 * 86400); // m3/s
      let Qb = k * Qann;

      let output = `Surface bassin: ${(A_m2/1e6).toFixed(2)} km²\n\nDébits journaliers estimés (m3/s):\n`;
      dailyQ.forEach((P_day, idx) => {
        let Q = C * (P_day/1000) * A_m2 / 86400 + Qb;
        output += `Jour ${idx+1}: ${Q.toFixed(3)}\n`;
      });
      document.getElementById('output').textContent = output;
    }
  </script>
</body>
</html>
